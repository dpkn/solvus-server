<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stage</title>

    <link rel="stylesheet" href="no-signal.css">
</head>

<body>
    <section class="screen-disabled no-signal center-content" >
        <div class="center-content">
            <div>
                <h1>Stage #<span class="stageId"></span></h1>
                <h2><span class="screenSize"></span></h2>
                <span class="loaded">loaded: false</span>
                <span class="smpte">00:00:00:00</span><br>
                <span class="beat"></span><br>
                <span class="beat2"></span>
            </div>
        </div>
    </section>
    <video class="screen" id="screen" loop playsinline preload="auto">
        <source id="source" src="" type="video/mp4">
    </video>
 
    <script src="./socket.io.js"></script>
    <script src="./timesync.js"></script>
    <script src="./smpte.js"></script>
    <script src="./Clock.js"></script>
    <script src="./Client.js"></script>

    <script>

        // Get the Stage ?id= parameter from the url.
        let params = new URLSearchParams(document.location.search.substring(1));
        let stageId = params.get("id");
        document.querySelector('.stageId').innerHTML = stageId;

        // Connect to server
        let serverURI = window.location.host;

        const timeSocket = io(serverURI + '/time');
        const socket = io(serverURI + '/client');
        
        socket.on('beat',({beat, bpm})=>{
            document.querySelector('.beat').innerHTML = bpm+' ('+beat+')';
        })

        let tempoEvent;
        let beata = 0;
        socket.on('bpm',({bpma,timestamp})=>{
            if(tempoEvent){
                clearRequestInterval(tempoEvent);
            }
            beata = 0;
            let startDelay = timestamp - new Date(ts.now());
            console.log(startDelay, timestamp)
            requestTimeout(()=>{
            tempoEvent = requestInterval(() => {
                    //console.log('beat '+tempo);
                    beata++;

                    document.querySelector('.beat2').innerHTML = ' (' + beata + ')';

                    if (beata > 3) {
                        beata = 0;
                    }

                }, 60000 / bpma)
            },startDelay);

        });

        let client = new Client(socket, stageId);

        let ts = timesync.create({
            server: '/timesync',
            interval: 50
        });


    /**
     * Behaves the same as setTimeout except uses requestAnimationFrame() where possible for better performance
     * @param {function} fn The callback function
     * @param {int} delay The delay in milliseconds
     */

    window.requestTimeout = function (fn, delay) {
        if (!window.requestAnimationFrame &&
            !window.webkitRequestAnimationFrame &&
            !(window.mozRequestAnimationFrame && window.mozCancelRequestAnimationFrame) && // Firefox 5 ships without cancel support
            !window.oRequestAnimationFrame &&
            !window.msRequestAnimationFrame) {
            console.log('unsupported')
            return window.setTimeout(fn, delay);
        }

        var start = new Date().getTime(),
            handle = new Object();

        function loop() {
            var current = new Date().getTime(),
                delta = current - start;

            delta >= delay ? fn.call() : handle.value = requestAnimFrame(loop);
        };

        handle.value = requestAnimFrame(loop);
        return handle;
    };

    /**
     * Behaves the same as clearTimeout except uses cancelRequestAnimationFrame() where possible for better performance
     * @param {int|object} fn The callback function
     */
    window.clearRequestTimeout = function (handle) {
        window.cancelAnimationFrame ? window.cancelAnimationFrame(handle.value) :
            window.webkitCancelAnimationFrame ? window.webkitCancelAnimationFrame(handle.value) :
                window.webkitCancelRequestAnimationFrame ? window.webkitCancelRequestAnimationFrame(handle.value) : /* Support for legacy API */
                    window.mozCancelRequestAnimationFrame ? window.mozCancelRequestAnimationFrame(handle.value) :
                        window.oCancelRequestAnimationFrame ? window.oCancelRequestAnimationFrame(handle.value) :
                            window.msCancelRequestAnimationFrame ? window.msCancelRequestAnimationFrame(handle.value) :
                                clearTimeout(handle);
    };
    window.requestAnimFrame = (function () {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function (/* function */ callback, /* DOMElement */ element) {
                    window.setTimeout(callback, 1000 / 60);
                };
        })();

    /**
     * Behaves the same as setInterval except uses requestAnimationFrame() where possible for better performance
     * @param {function} fn The callback function
     * @param {int} delay The delay in milliseconds
     */
        window.requestInterval = function (fn, delay) {
            if (!window.requestAnimationFrame &&
                !window.webkitRequestAnimationFrame &&
                !(window.mozRequestAnimationFrame && window.mozCancelRequestAnimationFrame) && // Firefox 5 ships without cancel support
                !window.oRequestAnimationFrame &&
                !window.msRequestAnimationFrame)
                return window.setInterval(fn, delay);

            var start = new Date().getTime(),
                handle = new Object();

            function loop() {
                var current = new Date().getTime(),
                    delta = current - start;

                if (delta >= delay) {
                    fn.call();
                    start = new Date().getTime();
                }

                handle.value = requestAnimFrame(loop);
            };

            handle.value = requestAnimFrame(loop);
            return handle;
        }

        /**
         * Behaves the same as clearInterval except uses cancelRequestAnimationFrame() where possible for better performance
         * @param {int|object} fn The callback function
         */
        window.clearRequestInterval = function (handle) {
            window.cancelAnimationFrame ? window.cancelAnimationFrame(handle.value) :
                window.webkitCancelAnimationFrame ? window.webkitCancelAnimationFrame(handle.value) :
                    window.webkitCancelRequestAnimationFrame ? window.webkitCancelRequestAnimationFrame(handle.value) : /* Support for legacy API */
                        window.mozCancelRequestAnimationFrame ? window.mozCancelRequestAnimationFrame(handle.value) :
                            window.oCancelRequestAnimationFrame ? window.oCancelRequestAnimationFrame(handle.value) :
                                window.msCancelRequestAnimationFrame ? window.msCancelRequestAnimationFrame(handle.value) :
                                    clearInterval(handle);
        };

    </script>
</body>
</html>